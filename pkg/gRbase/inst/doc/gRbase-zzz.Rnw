% \VignetteIndexEntry{gRbase: A Common Platform for Graphical Models (deprecated)}
% \VignetteDepends{gRbase}
% \VignetteKeyword{Graphical Models}
% \VignetteKeyword{Graphical Models}
% \VignetteKeyword{Hierarchical log-linear models}
% \VignetteKeyword{Graphical Gaussian models}



\documentclass{article}

%% For Danish letters. 
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{Sweave,amsmath,amsfonts,bm}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}



\newcommand{\package}[1]{\textsf{\small{#1}}}
\newcommand{\trans}{\ensuremath{^\prime}}
\renewcommand{\vec}{\operatorname{vec}}

\def\shd#1{\footnote{SHD #1}}
\def\pkg#1{\texttt{#1}}
\def\code#1{\texttt{#1}}
\def\textit#1{\texttt{#1}}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}


\def\gR                 {\code{gR}}
\def\CoCo                 {\code{CoCo}}
\def\BUGS                 {\code{BUGS}}
\def\Digram                 {\code{Digram}}
\def\tetrad                 {\code{Tetrad}}
\def\JAGS                 {\code{JAGS}}
\def\loglm                 {\code{loglm}}
\def\loglin                 {\code{loglin}}
\def\gR                 {\code{gR}}
\def\hllm                 {\code{hllm}}
\def\gRbase                 {\pkg{gRbase}}
\def\giRaph                 {\pkg{giRaph}}
\def\dynamicGraph                 {\pkg{dynamicGraph}}
\def\mimterm            {\code{MIMterm}}
\def\mimcmd             {\code{mim.cmd}}
\def\mcm                {\code{mcm}}
\def\mimmod             {\code{mim.model}}
\def\mimprint           {\code{mim.print}}
\def\gmData            {\code{gmData}}
\def\gmData             {\code{gmData}}
\def\mimModel           {\code{mimModel}}
\def\mimmodel           {\code{mim}} % {\code{mim.model}}
\def\mimbrmodel         {\code{mim.br.model}}%  {\code{mim.br.model}}
\def\mimchain           {\code{mim.chain}}
\def\mimBRModel         {\code{mim.chain}} % {\code{mimBRModel}}
\def\gModel             {\code{gModel}} % {\code{mimUndirModel}}
\def\mimUndirModel      {\gModel} % {\code{mimUndirModel}}
\def\mimFormula         {\code{mimFormula}}
\def\UndirectedFormula  {\code{UndirectedFormula}}
\def\BRFormula          {\code{BRFormula}}
\def\editmim            {\code{editmim}}
%%
% CD
%\def\mimR               {\texttt{\bf\color{darkblue}mimR}}
%\def\R                  {\textsf{\bf\color{darkblue}R}}
%\def\mim                {\texttt{\bf\color{darkblue}MIM}}
\def\mimR               {\pkg{mimR}}
\def\R                  {\textsf{\bf R}}
%\def\mim                {\texttt{\bf MIM}}
\def\mim                {\code{MIM}}
%\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}



\author{
  Claus Dethlefsen\\Aalborg Hospital, Aarhus University Hospital, Denmark
\and 
  S{\o}ren H{\o}jsgaard\\Aalborg University, Denmark
}

\title{On the Usage of the  \pkg{gRbase} Package\\ --- \\
Notice: The functionality described in this note is not being
maintained / developed further. Graphical modelling facilities are
provided in the  \pkg{gRim} package} 


\begin{document}

\maketitle
\tableofcontents

\parindent0pt\parskip5pt

\section{Introduction}


This document is a supplement to \cite{cd:shd:05} (hereafter called
CDSH) which is the formal reference to the \gRbase\ package. In CDSH
several broader perspectives are outlined and references to
litterature as well as to software are given. The present document is
more down to earth as it describes what is actually working.

The core of \gRbase\ is the \gmData\ and \gModel\ classes described below.


\paragraph{\protect\gmData\ objects:}

A fundamental element of \gRbase\ is a common class for representing
data. No matter the actual representation of data, the important
characteristics are contained in a graphical metadata (\gmData)
object. It contains the abstraction of data into a meta data object
including variable names and types etc. 
Also, it may be possible to work without data,
which may be valuable if the point of interest is in the model alone.

Separating the specification of the variables from data has the
benefit, that some properties of a model can be investigated without
any reference to data, for example decomposability and collapsibility.
The \gmData\ class is described in Section~\ref{sec:gmData}.

In principle this allows for working with a reference to data, such as
a database. This enables modelling although data are unavailable at
the time of modelling, or if the data-amount is huge or if the data
changes dynamically.


\paragraph{\protect\gModel\ objects:}

A \gModel\ object links a model specification to a \gmData\ object. 
The model given by a model specification which can be quite
arbitrary but which might be a formula. 

When defining a \gModel\ object, no fitting is done. This is an
important difference between model in \gRbase\ and e.g.\ linear models
in the function \verb|lm| in \R. There are two reasons for this: First
that some aspects of a model may be of interest without any reference
to data. Secondly once a model is to be fitted to data, there may be
several possible ``engines'' for doing so. For example, one might fit
a graphical Gaussian model with maximum likelihood or by working with
another type of estimating function.
The \gModel\ class is described in Section~\ref{sec:gmodel}.


Some features of \gRbase\ will be illustrated in the present paper on
the basis of the \verb+rats+ dataset in the \gRbase\ package.  The
\verb+rats+ dataset is from a hypothetical drug trial, where the
weight losses of male and female rats under three different drug
treatments have been measured after one and two weeks. The dataset is
provided in the \gRbase\ package, and is further described in
\cite{edwards:00}. We will also refer to the dataset
\verb|HairEyeColor| \citep{haireyecolor}, included in \R. 



\section{A small sample session}
\label{sec:samplesession}
Before describing the core elements of \gRbase, we present a sample
session intended to give the reader a feel for how an end user will use
\gRbase.

Creating a gmData object first, data are created as a \gmData\
object from an existing \code{table} object.  

\footnotesize
<<results=hide,echo=F>>=
options(width=85)
library(gRbase)
<<>>=
library(gRbase)
data(HairEyeColor)
gmdHec  <- as.gmData(HairEyeColor)  # define data
gmdHec

valueLabels(gmdHec)
@ 
\normalsize

Then, the model with sex independent of hair-colour and eye-colour is
defined, fitted (with the \code{loglm}-engine) and finally the output
is analysed using the \code{anova} procedure to test the model against
the saturated model.

\footnotesize
<<>>=
hecM1 <- hllm(~Hair*Eye+Sex,gmdHec)# indep. of Sex   
hecM1 <- fit(hecM1,engine="loglm")   
anova(getFit(hecM1))                   # test against saturated model
@ %def
\normalsize

\section[The gmData class]{The \protect\gmData\ class}
\label{sec:gmData}

A \gmData\ object contains, by default, information about variable
names, variable types, their labels, their levels (for discrete
variables), and whether the variables are latent or not. Unique
abbreviations (short names) of the variable names are created for ease
of use when specifying model formulas. Besides, a \gmData\ object may
contain data or a reference to data, but need not do so.

\subsection[Creating a gmData object from a data frame or a table]%
{Creating a \protect\gmData\ object from a data frame or a table}


Typically one will create a \gmData\ object (with data) from a data
frame as follows. Section~\ref{sec:samplesession} showed how to do
this for a table. For a data frame the scheme is the same:

\footnotesize
<<>>=
data(rats)
gmdRats <- as.gmData(rats)
gmdRats
@ 
\normalsize


\normalsize
Observe, that when an object is printed, only the summary of the
variables are printed. Data and value labels are not displayed, but
may be accessed separately.

\subsection[Creating a gmData object manually]%
{Creating a \protect\gmData\ object manually}

A \gmData\ object may be created with \code{newgmData}:
\footnotesize 
<<>>=
gmdRatsNodata  <-  newgmData(
                         varNames=c("Sex","Drug","W1","W2"),
                         varTypes=c("Discrete", "Discrete",
"Continuous", "Continuous"),
                         nLevels=c(2,3,NA,NA), 
                         valueLabels=list( Sex=c("M", "F"),
Drug=c("D1", "D2", "D3")))
gmdRatsNodata
valueLabels(gmdRatsNodata)
@ 
\normalsize


Note that there is some redundancy in the specification above: The
value of \code{nLevels} can be deduced from \code{valueLabels}.
Therefore \code{nLevels} needs not to be specified. If
\code{valueLabels} are not given, then default labels are created
based on \code{nLevels}. If neither \code{nLevels} nor
\code{valueLabels} are given, then all discrete variables are assumed
to be binary. Following this convention we can write

\footnotesize 
@ 
<<>>=
d  <-  newgmData(varNames=c("Sex","Drug","W1","W2"),
                 varTypes=c("Discrete", "Discrete",
"Continuous", "Continuous"))
d
valueLabels(d)
@ %def 
\normalsize


\paragraph{Valid variable types}

Default is that the valid variable types are as given by the function 
\code{validVarTypes()}:
\footnotesize
@ 
<<>>=
validVarTypes()
@ %def 
\normalsize
The valid variable types can be extended. This could  be of relevance if
e.g.\ a variable $y$ takes only strictyly positive values and 
should  be ``read as'' $\log
y$. Then we can extend the valid variable types as:
\footnotesize 
<<>>=
oldtypes <- validVarTypes()
validVartypes <- function() c(oldtypes, "PosCont")
validVartypes()
@ 
\normalsize


\subsection[Editing gmData objects]{Editing \protect\gmData\ objects}

The information contained in a \gmData\ object may be accessed or
modified by the methods: \code{varTypes}, \code{varNames},
\code{nLevels}, \code{latent}, \code{valueLabels}, and
\code{observations}. For example, to redefine the levels of the variable
\texttt{Sex}, we can do:

\footnotesize 
<<>>=
observations(gmdRatsNodata) <- rats
valueLabels(gmdRatsNodata)$Sex <- c("Male","Female")
valueLabels(gmdRatsNodata)
@ 
\normalsize


\subsection{Writing new conversion methods} 
\label{sec:xxx}

It is also possible to write conversion methods for other data types,
if needed. Suppose we have a $2\times 2$ table from cross classifying
factors \code{Aa} and \code{Bb} and that the counts (in some order)
are $12$, $20$, $33$ and $41$. We may represent data as e.g.\
\footnotesize 
@ 
<<>>=
d <- list(varNames=c("Aa","Bb"), nLevels=c(2,2), counts=c(12,20,33,41))
class(d) <- "countsList"
d
@ %def 
\normalsize

A conversion method can be defined as
\footnotesize 
@ 
<<>>=
as.gmData.countsList <- function(from){
  ans <- newgmData(varNames=from$varNames, nLevels=from$nLevels)
  observations(ans) <- from$counts
  return(ans)
}
@ %def 
\normalsize

Then we get:
\footnotesize
@ 
<<print=T>>=
gd<-as.gmData(d)
valueLabels(gd)
observations(gd)
@ %def 
\normalsize


\section[The gModel class]{The \protect \gModel\ class}
\label{sec:gmodel}

The general class \gModel\ contains a formula object and a \gmData\
object. Implementations of different specific graphical model classes
can inherit from this class and provide methods for parsing the
formula. Here, we illustrate by implementation of a class for
hierarchical log--linear models, \code{hllm}.

For a hierarchical log--linear model, we use the following formula
language. The right hand side of the formula is a list of the
generators separated by '+'. A generator is specified by variable
names with separated by '*'. Commonly used models have short hand
notations: saturated model (\verb|~.^.|), main effects (\verb|~.^1|),
all $k$th order interactions (\verb|~.^k|). By an optional argument,
\code{marginal}, it is possible to specify a subset of the variables
from the \gmData\ object.

%<<results=hide,echo=F>>=
%options(width=88)
\footnotesize 
<<results=hide,echo=F>>=
#options(width=50)
@ 
\normalsize
The saturated model
\footnotesize 
<<results=hide,echo=F>>=
#options(width=50)
<<>>=
m1 <- hllm(~.^.,gmdHec)   # saturated
formula(m1)
@ 
\normalsize
The model where sex is independent of hair- and eye-color
\footnotesize 
<<results=hide,echo=F>>=
#options(width=50)
<<>>=
m2 <- hllm(~Hair*Eye+Sex,gmdHec)
@
\normalsize
The model with all main effects
\footnotesize 
<<results=hide,echo=F>>=
#options(width=50)
<<>>=
m3 <- hllm(~.^1,gmdHec)   # all main effects
formula(m3)
@ 
\normalsize
The saturated model in the hair-eye marginal
\footnotesize 
<<results=hide,echo=F>>=
#options(width=50)
<<>>=
m4 <- hllm(~.^.,gmdHec,marginal=c("Hair","Eye")) 
formula(m4)
@ 
\normalsize

Also, the \gModel\ class will have associated methods for making
inference, which will be treated in Section~\ref{inference}.

\subsection{Model editing}
\label{sec:model-select-model}

One important aspect of graphical modelling is the ability to interact
with the model. Editing the model means \eg\ that edges are added or
removed and the resulting model is further investigated.  The package
developer needs to provide the methods \code{addEdge} and
\code{dropEdge} for his model class.


In addition, variables may be added or deleted from the model
by the methods \code{dropVertex}
and \code{addVertex}, which should also be provided by the package
developer.

It is up to the package developer to define the body of these methods.
The output should be an object similar to the input object. If for
example the input object is a fitted object, the returned object
should also be fitted with the same engine.



\section*{Acknowledgements}

The members of the gR project are acknowledged for their inspiration.

\bibliography{fulldef,gRbase}

\end{document}



% \footnotesize 
% <<eval=F,echo=F,eval=F>>=
% #options(width=50)
% <<>>=
% m5 <- addEdge(m2,"Hair","Sex")
% formula(m5)
% m6 <- dropEdge(m5,"Hair","Eye")
% formula(m6)
% @ 
% \normalsize


% \begin{abstract}The \gRbase\ package is intended to set the framework for
%   computer packages for data analysis using graphical models.  The
%   \gRbase\ package is developed for the open source language, \R, and
%   is available for several platforms.  The package is intended to be
%   widely extendible and flexible so that package developers may
%   implement further types of graphical models using the available
%   methods.

%   The \gRbase\ package consists of a set of S version 3
%   classes and associated methods for representing data and models. The
%   package is linked to the \pkg{dynamicGraph} package,
%   \cite{badsberg:04}, an interactive graphical user interface for
%   manipulating graphs.

%   In this paper, we show how these building blocks can be combined and
%   integrated with inference engines in the special cases of
%   hierarchical log--linear models. We also illustrate how to extend
%   the package to deal with other types of graphical models, in this
%   case the graphical Gaussian models.
% \end{abstract}


% Graphical models in their modern form have been around for nearly
% a quarter of a century. In the present context, a graphical model is a
% class of statistical models that can be represented by a graph which
% can be used to identify conditional independence properties.  For
% terminology and theoretical aspects of graphical models, see e.g.\
% \cite{lauritzen:96}. Some common examples of graphical models are
% Bayesian networks (directed graphical models), log--linear models
% (undirected models), block-recursive graphical models, and models
% defined in the \BUGS\ language, see \cite{thomas:94}.


% Various computer programs for inference in graphical models exist
% today.  Some examples of free software programs are \BUGS\
% \citep{thomas:94}, \CoCo\ 
% \citep{badsberg:01}, \Digram\ \citep{klein:keiding:kreiner:95}, \mim\
% \citep{edwards:00}, and \tetrad\ \citep{glymour:scheines:spirtes:kelley:87}.
% Most such packages for graphical models have common characteristics:
% 1) They are tailor-made to analyse a particular class of models, 2)
% they have their own command language. Recently the source code of
% \BUGS\ and \mim\ were released as Open Source, making it possible to
% extend the functionality by integrating these packages into more
% general tools.
% %are not possible to extend since the code is not open source.

% It is of interest to make some of these programs and ideas underlying
% them go into a general purpose statistical package. The \gR\
% initiative \citep{lauritzen:02} is a project launched in 2002 for
% making facilities in \R\ \citep{R} for graphical modelling. The
% facilities should be easy to use, and they should be easily
% extendable. \R\ is Free Software, Open Source, and runs on various
% platforms. This facilitates extensions in the form of \R\ packages
% which may rely on the whole \R\ system.

% Recently, some of the existing graphical modelling programs have been
% made available in \R. One example is the \mimR\ package
% \citep{hojsgaard:04} which integrates the functionality of the
% stand--alone program \mim\ into \R. Also,
% the \CoCo\ program is now available in \R.  Other packages for
% graphical modelling available in \R\ are \pkg{ggm}
% \citep{marchetti:04}, \pkg{deal} \citep{bottcher:dethlefsen:03}, and
% \pkg{SIN} \citep{drton:perlman:04}.

% The work in the \gR\ initiative is organized in three levels: A
% \textit{core group} works with defining data structures and standard
% methods, in particular developing the packages \gRbase, \dynamicGraph\
% (see Section~\ref{sec:display}), and \giRaph.  The latter package,
% which is not described in this paper provides methods for representing
% and manipulating graphs efficiently. The \textit{package developers}
% use the work from the core group to adapt or develop new packages for
% \R\ that use a common user interface and data structures. Finally, the
% \textit{group of end users} use the developed packages in their work
% with data or model analysis.

% In this paper we describe the elements of \gRbase\ (available from
% \url{cran.r-project.org}) and illustrate how to combine them to create
% facilities for analysis of hierarchical log--linear models for
% discrete variables (undirected models). We also illustrate how to
% extend \gRbase\ for other classes of models, here 
% graphical Gaussian models.%   We have chosen to implement \gRbase\ using
% % the S4 class system of \R.
